/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options {  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(ATScriptParser)package com.gpl.rpg.AndorsTrail.scripting.interpreter;

import java.io.BufferedReader;
import java.io.StringReader;

import java.util.Map;
import java.util.List;
import java.util.ArrayList;

public class ATScriptParser {

	public static final String LOCALINT_COUNT_KEY = "localIntCount";
	public static final String LOCALBOOL_COUNT_KEY = "localBoolCount";
	public static final String LOCALSTRING_COUNT_KEY = "localStringCount";
	public static final String LOCALINT_SCOPECOUNT_KEY = "localIntScopeCount";
	public static final String LOCALBOOL_SCOPECOUNT_KEY = "localBoolScopeCount";
	public static final String LOCALSTRING_SCOPECOUNT_KEY = "localStringScopeCount";
	public static final String LOCALVAR_TYPE_KEY_SUFFIX = "__localVarType";
	public static final String LOCALVAR_INDEX_KEY_SUFFIX = "__localVarIndex";
	public static ATSNode parseScript(String script, Map<String, Object> localVarRefHelp) throws ParseException {		StringReader reader = new StringReader(script);
		BufferedReader scriptReader = new BufferedReader(reader);
		ATScriptParser parser = new ATScriptParser(scriptReader);		try {			return parser.parseScope(localVarRefHelp);		} catch (Exception e) {			e.printStackTrace();		} catch (Error e) {			e.printStackTrace();		}
		return null;	}}PARSER_END(ATScriptParser)SKIP : {  " "| "\r"| "\t"| "\n"}TOKEN :  {	<DOT : ".">
|	<LPAR : "(">
|	<RPAR : ")">
|	<LBRAC : "{">
|	<RBRAC : "}">
|	<SCOL : ";">
|	<COMA : ",">
|	<IF : "if">
|	<ELSE : "else">
|	<WHILE : "while">
|	<RETURN : "return">
|	<TRUE : "true">
|	<FALSE : "false">
|	<EXCLAM : "!">
|	<GOE : ">=">
|	<LOE : "<=">
|	<GT : ">">
|	<LT : "<">
|	<EQ : "==">
|	<PLUS : "+">
|	<MINUS : "-">
|	<MULTIPLY : "*">
|	<DIVIDE : "/">
|	<AND : "&&">
|	<OR : "||">
|	<EQUALS : "=">
|	<DQUO : "\""> : LITERAL
|	<NUMBER : (["-"])?(["0"-"9"])+(["."](["0"-"9"])+)?>
|	<MAP : "map">
|	<WORLD : "world">
|	<ATTACK : "attack">
|	<PLAYER : "player">
|	<ACTOR : "actor">
|	<OUTDOOR : "outdoor">
|	<MIN : "min">
|	<MAX : "max">
|	<CURRENT : "current">
|	<SOURCE : "source">
|	<TARGET : "target">
|	<DAMAGE : "damage">
|	<ADDCONDITION : "addActorCondition">
|	<CLEARCONDITION : "clearActorCondition">
|	<HP : "hp">
|	<AP : "ap">
|	<AC : "ac">
|	<AD : "ad">
|	<BC : "bc">
|	<DR : "dr">
|	<CC : "cc">
|	<CM : "cm">
|	<BOOL : "bool">
|	<NUM : "num">
|	<STRING : "string">
|	<IDENTIFIER : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","-","_"])*>}

<LITERAL>
TOKEN : {
	<ESCAPED_DQUO : "\\\"">
|	<DQUOBIS : "\""> : DEFAULT
|	<LITERAL_VALUE : (~["\"","\\"])+>
}

ATSExpression parseScope(Map<String, Object> localVars) : {
	ATSExpression scriptRoot;
	int prevScopeInt = (Integer)localVars.get(LOCALINT_COUNT_KEY);
	int prevScopeBool = (Integer)localVars.get(LOCALBOOL_COUNT_KEY);
	int prevScopeString = (Integer)localVars.get(LOCALSTRING_COUNT_KEY);
	List<String> prevScopeLocalVarNames = new ArrayList<String>();
	for (String key : localVars.keySet()) {
		if (key.endsWith(LOCALVAR_TYPE_KEY_SUFFIX)) {
			prevScopeLocalVarNames.add(key);
		}
	}
} {
	scriptRoot = parseScript(localVars)
	{
		localVars.put(LOCALINT_SCOPECOUNT_KEY, Math.max((Integer)localVars.get(LOCALINT_SCOPECOUNT_KEY),(Integer)localVars.get(LOCALINT_COUNT_KEY)));
		localVars.put(LOCALBOOL_SCOPECOUNT_KEY, Math.max((Integer)localVars.get(LOCALBOOL_SCOPECOUNT_KEY),(Integer)localVars.get(LOCALBOOL_COUNT_KEY)));
		localVars.put(LOCALSTRING_SCOPECOUNT_KEY, Math.max((Integer)localVars.get(LOCALSTRING_SCOPECOUNT_KEY),(Integer)localVars.get(LOCALSTRING_COUNT_KEY)));
		localVars.put(LOCALINT_COUNT_KEY, prevScopeInt);
		localVars.put(LOCALBOOL_COUNT_KEY, prevScopeBool);
		localVars.put(LOCALSTRING_COUNT_KEY, prevScopeString);
		List<String> newLocalVarNames = new ArrayList<String>();
		for (String key : localVars.keySet()) {
			if (!prevScopeLocalVarNames.contains(key)) {
				if (key.endsWith(LOCALVAR_TYPE_KEY_SUFFIX)) {
					newLocalVarNames.add(key);
				}
			}
		}
		for (String key : newLocalVarNames) {
			localVars.remove(key);
		}
		return scriptRoot;
	}
}
ATSExpression parseScript(Map<String, Object> localVars) : {
	ATSExpression scriptRoot, next;
} {
	scriptRoot = construct(localVars) next = parseScript(localVars)
	{
		scriptRoot.next = next;
		return scriptRoot;
	}
|	<EOF>
	{
		return null;
	}
|	<RBRAC>
	{
		return null;
	}
}

ATSExpression construct(Map<String, Object> localVars) : {
	ATSExpression construct;
} {
	construct = associationOrMethodCall(localVars) 
	{
		return construct;
	}
|	construct = ifElseConstruct(localVars) 
	{
		return construct;
	}
|	construct = whileConstruct(localVars) 
	{
		return construct;
	}
|	construct = returnConstruct(localVars) 
	{
		return construct;
	}
}

ATSExpression associationOrMethodCall(Map<String, Object> localVars) : {
	ATSValueReference assignee;
	ATSValueReference value = null;
} {
	assignee = reference(localVars) (<EQUALS> value = value(localVars))? <SCOL>
	{
		if (value != null) {
			return new ATSAssociation(assignee, value);
		} else {
			//Method call...
			return assignee;
		}
	} 
}

ATSValueReference reference(Map<String, Object> localVars) : {
	ATSValueReference assignee;
} {
	assignee = localVarDeclaration(localVars)
	{
		return assignee;
	}
|	assignee = contextVarReference(localVars)
	{
		return assignee;
	}
}

ATSValueReference localVarDeclaration(Map<String, Object> localVars) : {
	Token id;
	int index;
} {
	<BOOL> id = <IDENTIFIER>
	{
		if (localVars.get(id.image)!=null) {
			throw new ParseException("ATScript : Duplicate variable "+id.image+" at line "+id.beginLine+" column "+id.beginColumn);
		}
		index = (Integer)localVars.get(LOCALBOOL_COUNT_KEY);
		localVars.put(LOCALBOOL_COUNT_KEY, index + 1);
		localVars.put(id.image+LOCALVAR_TYPE_KEY_SUFFIX, ATSLocalVarReference.VarType.bool);
		localVars.put(id.image+LOCALVAR_INDEX_KEY_SUFFIX, index);
		return new ATSLocalVarReference(ATSLocalVarReference.VarType.bool, index);
	}
|	<NUM> id = <IDENTIFIER>
	{
		if (localVars.get(id.image)!=null) {
			throw new ParseException("ATScript : Duplicate variable "+id.image+" at line "+id.beginLine+" column "+id.beginColumn);
		}
		index = (Integer)localVars.get(LOCALINT_COUNT_KEY);
		localVars.put(LOCALINT_COUNT_KEY, index + 1);
		localVars.put(id.image+LOCALVAR_TYPE_KEY_SUFFIX, ATSLocalVarReference.VarType.num);
		localVars.put(id.image+LOCALVAR_INDEX_KEY_SUFFIX, index);
		return new ATSLocalVarReference(ATSLocalVarReference.VarType.num, index);
	}
|	<STRING> id = <IDENTIFIER>
	{
		if (localVars.get(id.image)!=null) {
			throw new ParseException("ATScript : Duplicate variable "+id.image+" at line "+id.beginLine+" column "+id.beginColumn);
		}
		index = (Integer)localVars.get(LOCALSTRING_COUNT_KEY);
		localVars.put(LOCALSTRING_COUNT_KEY, index + 1);
		localVars.put(id.image+LOCALVAR_TYPE_KEY_SUFFIX, ATSLocalVarReference.VarType.string);
		localVars.put(id.image+LOCALVAR_INDEX_KEY_SUFFIX, index);
		return new ATSLocalVarReference(ATSLocalVarReference.VarType.string, index);
	}
}

ATSValueReference contextVarReference(Map<String, Object> localVars) : {
	ATSValueReference reference;
	Token id;
} {
	<MAP> <DOT> reference = mapReference(localVars)
	{
		return reference;
	}
|	<ATTACK> <DOT> reference = attackReference(localVars)
	{
		return reference;
	}
|	<PLAYER> <DOT> reference = playerReference(localVars)
	{
		return reference;
	}
|	<ACTOR>	<DOT> reference = actorReference(localVars, new ATSContextObjectReference(ATSContextObjectReference.ContextObject.actor))
	{
		return reference;
	}
|	<WORLD>	<DOT> reference = worldReference(localVars)
	{
		return reference;
	}
|	id = <IDENTIFIER>
	{
		if (!localVars.containsKey(id.image+LOCALVAR_TYPE_KEY_SUFFIX)) {
			throw new ParseException("Undeclared variable "+id.image+" at line"+id.beginLine+" column "+id.beginColumn);
		}
		return new ATSLocalVarReference((ATSLocalVarReference.VarType)localVars.get(id.image+LOCALVAR_TYPE_KEY_SUFFIX), (Integer)localVars.get(id.image+LOCALVAR_INDEX_KEY_SUFFIX));
	}
}

ATSExpression whileConstruct(Map<String, Object> localVars) : {
	ATSExpression block;
	ATSValueReference condition;
} {
	<WHILE> <LPAR> condition = value(localVars) <RPAR> <LBRAC> block = parseScope(localVars)
	{
		return new ATSWhileLoop(condition, block);
	}
}

ATSExpression ifElseConstruct(Map<String, Object> localVars) : {
	ATSExpression ifBlock, elseBlock=null;
	ATSValueReference ifCondition;
} {
	<IF> <LPAR> ifCondition = value(localVars) <RPAR> <LBRAC> ifBlock = parseScope(localVars) ( <ELSE> elseBlock = elseBlock(localVars))?
	{
		return new ATSFlowControl(ifCondition,ifBlock,elseBlock);
	}
}

ATSExpression elseBlock(Map<String, Object> localVars) : {
	ATSExpression block;
} {
	<LBRAC> block = parseScope(localVars)
	{
		return block;
	}
|	block = ifElseConstruct(localVars)
	{
		return block;
	}
}

ATSExpression returnConstruct(Map<String, Object> localVars) : {
	ATSValueReference value;
} {
	<RETURN> value = value(localVars)
	{
		return new ATSReturnStatement(value);
	}
}

ATSValueReference value(Map<String, Object> localVars) : {
	ATSValueReference reference;
	ATSPrimitiveOperation operation = null;
	Token tok;
} {
	reference = reference(localVars) (operation = valueOp(localVars, reference)) ?
	{
		if (operation != null) {
			return operation;
		} else {
			return reference;
		}
	}
|	tok = <NUMBER> (operation = valueOp(localVars, new ATSConstantReference(new Double(tok.image)))) ?
	{
		if (operation != null) {
			return operation;
		} else {
			return new ATSConstantReference(new Double(tok.image));
		}
	}
|	<LPAR> reference = value(localVars) <RPAR>
	{
		return reference;
	}
|	<EXCLAM> reference = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.not, null, reference);
	}
|	<TRUE>
	{
		return new ATSConstantReference(Boolean.TRUE);
	}
|	<FALSE>
	{
		return new ATSConstantReference(Boolean.FALSE);
	}
|	<DQUO> tok=<LITERAL_VALUE> <DQUOBIS>
	{
		return new ATSConstantReference(tok.image);
	}
}


ATSPrimitiveOperation valueOp(Map<String, Object> localVars, ATSValueReference leftHand) : {
	ATSValueReference value;
} {
	<GT> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.gt, leftHand, value);
	}
|	<LT> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.lt, leftHand, value);
	}
|	<GOE> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.goe, leftHand, value);
	}
|	<LOE> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.loe, leftHand, value);
	}
|	<EQ> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.eq, leftHand, value);
	}
|	<PLUS> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.plus, leftHand, value);
	}
|	<MINUS> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.minus, leftHand, value);
	}
|	<MULTIPLY> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.multiply, leftHand, value);
	}
|	<DIVIDE> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.divide, leftHand, value);
	}
|	<AND> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.and, leftHand, value);
	}
|	<OR> value = value(localVars)
	{
		return new ATSPrimitiveOperation(ATSPrimitiveOperation.Operator.or, leftHand, value);
	}
}


ATSValueReference mapReference(Map<String, Object> localVars) : {
} {
	<OUTDOOR>
	{
		return new ATSObjectFieldReference(ATSObjectFieldReference.ObjectFields.mapOutdoor, null);
	}
}

ATSValueReference attackReference(Map<String, Object> localVars) : {
} {
	{
		return null;
	}
}

ATSValueReference playerReference(Map<String, Object> localVars) : {
	ATSValueReference ref;
} {
	ref = actorReference(localVars, new ATSContextObjectReference(ATSContextObjectReference.ContextObject.player))
	{
		return ref;
	}
}

ATSValueReference actorReference(Map<String, Object> localVars, ATSContextObjectReference targetInstance) : {
	ATSValueReference condId, condMagnitude, condDuration, condChance;
} {
	<AC>
	{
		return new ATSObjectFieldReference(ATSObjectFieldReference.ObjectFields.actorAc, targetInstance);
	}
|	<BC>
	{
		return new ATSObjectFieldReference(ATSObjectFieldReference.ObjectFields.actorBc, targetInstance);
	}
|	<ADDCONDITION> <LPAR> condId = value(localVars) <COMA> condMagnitude = value(localVars) <COMA> condDuration = value(localVars) <COMA> condChance = value(localVars) <RPAR>
	{
		return new ATSMethodCall(ATSMethodCall.ObjectMethod.actorAddCondition, new ATSValueReference[]{condId, condMagnitude, condDuration, condChance}, targetInstance);
	}
|	<CLEARCONDITION> <LPAR> condId = value(localVars)  <COMA> condChance = value(localVars) <RPAR>
	{
		return new ATSMethodCall(ATSMethodCall.ObjectMethod.actorClearCondition, new ATSValueReference[]{condId, condChance}, targetInstance);
	}
}

ATSValueReference worldReference(Map<String, Object> localVars) : {
} {
	{
		return null;
	}
}