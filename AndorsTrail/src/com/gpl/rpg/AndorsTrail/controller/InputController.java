package com.gpl.rpg.AndorsTrail.controller;

import android.content.Context;
import android.content.Intent;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnLongClickListener;

import com.gpl.rpg.AndorsTrail.activity.HeroinfoActivity;
import com.gpl.rpg.AndorsTrail.context.ControllerContext;
import com.gpl.rpg.AndorsTrail.context.WorldContext;
import com.gpl.rpg.AndorsTrail.util.Coord;
import com.gpl.rpg.AndorsTrail.util.L;

public final class InputController implements OnClickListener, OnLongClickListener{
	private final ControllerContext controllers;
	private final WorldContext world;

	private final Coord lastTouchPosition_tileCoords = new Coord();
	private int lastTouchPosition_dx = 0;
	private int lastTouchPosition_dy = 0;
	private long lastTouchEventTime = 0;
	private boolean isDpadActive = false;

	private int keyState_dx = 0;
	private int keyState_dy = 0;
	private boolean keyState_attack = false;
	private boolean keyState_flee = false;
	private boolean keyState_endturn = false;
	
	final private int KEY_UNHANDLED = 0; // Default, for unhandled keycodes
	final private int KEY_UP = 1;
	final private int KEY_DOWN = 2;
	final private int KEY_LEFT = 3;
	final private int KEY_RIGHT = 4;
	final private int KEY_UP_LEFT = 5;
	final private int KEY_UP_RIGHT = 6;
	final private int KEY_DOWN_LEFT = 7;
	final private int KEY_DOWN_RIGHT = 8;
	final private int KEY_ATTACK = 9;
	final private int KEY_FLEE = 10;
	final private int KEY_END_TURN = 11;
	final private int KEY_HERO_INFO = 12;
	
	private char keyMap[];  // Android keycode to internal key event mapping.  TODO: Configure via preferences

	public InputController(ControllerContext controllers, WorldContext world) {
		this.controllers = controllers;
		this.world = world;
		initializeKeyMap();
		
	}
	
/*	New keyboard handler.  Both Key Down and Key Up events handled to allow conditional behaviours.
	On 4-way dpad controllers, cursor keys, and WASD, diagonals are generated by chording two keys.
	Single-key diagonals are supported on numeric keypad and 8-way dpads (not seen/tested in the wild).

    Because two-key combos initially generate a ordinal movement (one key comes in first), which can
    be dangerous in tight spaces, modifiers are provided to "lock" the input until both keys are down.
    TODO: Use delay timer to enable chorded diagonals on first move?
 */

    // Map key codes to spectic internal actions  
	// TODO: Move mapping out of code, to JSON or XML file, or maybe eventually user preferences
	private void initializeKeyMap() {
		char key;

		keyMap = new char[1024]; // Should be a long time before android exceeds 1024 keycodes

		// Keys mapping to UP
		key = KEY_UP;
		keyMap[KeyEvent.KEYCODE_DPAD_UP] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_8] = key;
		keyMap[KeyEvent.KEYCODE_8] = key;
		keyMap[KeyEvent.KEYCODE_W] = key;

		// Keys mapping to DOWN
		key = KEY_DOWN;
		keyMap[KeyEvent.KEYCODE_DPAD_DOWN] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_2] = key;
		keyMap[KeyEvent.KEYCODE_2] = key;
		keyMap[KeyEvent.KEYCODE_S] = key;

		// Keys mapping to LEFT
		key = KEY_LEFT;
		keyMap[KeyEvent.KEYCODE_DPAD_LEFT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_4] = key;
		keyMap[KeyEvent.KEYCODE_4] = key;
		keyMap[KeyEvent.KEYCODE_A] = key;

		// Keys mapping to RIGHT
		key = KEY_RIGHT;
		keyMap[KeyEvent.KEYCODE_DPAD_RIGHT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_6] = key;
		keyMap[KeyEvent.KEYCODE_6] = key;
		keyMap[KeyEvent.KEYCODE_D] = key;

		// Keys mapping to UP_LEFT
		key = KEY_UP_LEFT;
		keyMap[KeyEvent.KEYCODE_DPAD_UP_LEFT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_7] = key;
		keyMap[KeyEvent.KEYCODE_7] = key;
		keyMap[KeyEvent.KEYCODE_MOVE_HOME] = key;

		// Keys mapping to UP_RIGHT		
		key = KEY_UP_RIGHT;
		keyMap[KeyEvent.KEYCODE_DPAD_UP_RIGHT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_9] = key;
		keyMap[KeyEvent.KEYCODE_9] = key;
		keyMap[KeyEvent.KEYCODE_PAGE_UP] = key;

		// Keys mapping to DOWN_LEFT
		key = KEY_DOWN_LEFT;
		keyMap[KeyEvent.KEYCODE_DPAD_DOWN_LEFT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_1] = key;
		keyMap[KeyEvent.KEYCODE_1] = key;
		keyMap[KeyEvent.KEYCODE_MOVE_END] = key;

		// Keys mapping to DOWN_RIGHT		
		key = KEY_UP_LEFT;
		keyMap[KeyEvent.KEYCODE_DPAD_DOWN_RIGHT] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_3] = key;
		keyMap[KeyEvent.KEYCODE_3] = key;
		keyMap[KeyEvent.KEYCODE_PAGE_DOWN] = key;

		// Keys mapping to ATTACK
		key = KEY_ATTACK;
		keyMap[KeyEvent.KEYCODE_DPAD_CENTER] = key;
		keyMap[KeyEvent.KEYCODE_BUTTON_A] = key;
		keyMap[KeyEvent.KEYCODE_SPACE] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_5] = key;

		// Keys mapping to FLEE		
		key = KEY_FLEE;
		keyMap[KeyEvent.KEYCODE_BUTTON_X] = key;
		keyMap[KeyEvent.KEYCODE_F] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_ENTER] = key;
		keyMap[KeyEvent.KEYCODE_ENTER] = key;

		// Keys mapping to END_TURN
		key = KEY_END_TURN;
		keyMap[KeyEvent.KEYCODE_BUTTON_Y] = key;
		keyMap[KeyEvent.KEYCODE_E] = key;
		keyMap[KeyEvent.KEYCODE_FORWARD_DEL] = key;
		keyMap[KeyEvent.KEYCODE_NUMPAD_DOT] = key;

		// Keys mapping to HERO_INFO 		
		key = KEY_HERO_INFO;
		keyMap[KeyEvent.KEYCODE_BUTTON_SELECT] = key;
		keyMap[KeyEvent.KEYCODE_C] = key;
	}

	// Generate game actions based on mapped keys
	public boolean onKeyboardAction(Context context, KeyEvent event) {
		L.log("onKeyboardAction(): Processing action " + event.getAction() + " for keyCode " + event.getKeyCode());

		if (event.getAction() != KeyEvent.ACTION_DOWN && event.getAction() != KeyEvent.ACTION_UP) return false; // don't handle other actions

		boolean keydown = (event.getAction() == KeyEvent.ACTION_DOWN);
		boolean inihbit =  (keyState_attack || keyState_endturn || keyState_flee); // used to inhibit movement if an action key is held down

		if (event.getKeyCode() >= keyMap.length) return false; // just in case we get an oddball keycode
		
		switch (keyMap[event.getKeyCode()]) {
			// Basic movement handled first

			// Ordinal directional keys - only modify one direction register, can be combined when
			// used simultaneously to create synthetic diagonals
			case KEY_UP:
				keyState_dy = keydown ? -1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_DOWN:
				keyState_dy = keydown ? 1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_LEFT:
				keyState_dx = keydown ? -1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_RIGHT:
				keyState_dx = keydown ? 1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;

			// Diagonal directional keys.  Modify both direction registers, can't be combined
			// TODO: store individual key position to allow combinations.  May not be worth the trouble.
			case KEY_UP_LEFT:
				keyState_dx = keydown ? -1 : 0;
				keyState_dy = keydown ? -1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_UP_RIGHT:
				keyState_dx = keydown ? 1 : 0;
				keyState_dy = keydown ? -1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_DOWN_LEFT:
				keyState_dx = keydown ? -1 : 0;
				keyState_dy = keydown ? 1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;
			case KEY_DOWN_RIGHT:
				keyState_dx = keydown ? 1 : 0;
				keyState_dy = keydown ? 1 : 0;
				if (!inihbit) onRelativeMovement(keyState_dx, keyState_dy);
				break;

			// Special key handling below - some combat/movement stuff done here because it's too 
			// specific for logic in onRelativeMovement
			
			// "Attack" shortcut - freeze movement to allow chorded direction when key is released.
			// if in combat, executes an attack on key release
			case KEY_ATTACK:
				if (keydown && !keyState_attack) { // key pressed - pause movement
					if(!world.model.uiSelections.isInCombat) controllers.movementController.stopMovement();
				} else if (!keydown && keyState_attack) { // key released - execute attack / move in direction
					onRelativeMovement(keyState_dx, keyState_dy);
				}
				keyState_attack = keydown;
				break;

			// "Flee" shortcut.  Intitiates flee when pressed.  If a direction is held, moves in chosen direction when released
			case KEY_FLEE:
				if (world.model.uiSelections.isInCombat) {
					if (keydown && !keyState_flee) { // button pressed - set flee; movement locked while pressed
						controllers.combatController.startFlee();
					} else if (!keydown && keyState_flee) { // button released - move flee direction, if chosen
						// if no movement, executeMoveAttack() in will just attack again, so we have to check and do it here
						if ((keyState_dx != 0 || keyState_dy != 0) && allowInputInterval()) {
							controllers.combatController.executeMoveAttack(keyState_dx, keyState_dy);
						}
					}
				}
				keyState_flee = keydown;
				break;

			// "End Turn" shortcut.  Flag prevents repeated end turn if key is held down.
			case KEY_END_TURN:
				if (keydown && !keyState_endturn) {
					if (world.model.uiSelections.isInCombat) controllers.combatController.endPlayerTurn();
				}
				keyState_endturn = keydown;
				break;
			
			// "Hero Info" screen shortcut.  New activity takes focus, so we don't need to worry about repeats.
			case KEY_HERO_INFO:
				if (keydown) context.startActivity(new Intent(context, HeroinfoActivity.class));
				break;
			
			case KEY_UNHANDLED: // Unhandled keycode
			default: // unhandled keymap code entry (should not happen)
				return false;
		}

		return true;
	}

	public void onRelativeMovement(int dx, int dy) {
		if (world.model.uiSelections.isInCombat) {
			if (!allowInputInterval()) return;
			controllers.combatController.executeMoveAttack(dx, dy);
		} else if (keyState_dx == 0 && keyState_dy == 0) {
			controllers.movementController.stopMovement();
		} else {
			controllers.movementController.startMovement(dx, dy, null);
		}
	}

	public void onKeyboardCancel() {
		controllers.movementController.stopMovement();
	}

	@Override
	public void onClick(View arg0) {
		if (!world.model.uiSelections.isInCombat) return;
		onRelativeMovement(lastTouchPosition_dx, lastTouchPosition_dy);
	}

	@Override
	public boolean onLongClick(View arg0) {
		if (world.model.uiSelections.isInCombat) {
			//TODO: Should be able to mark positions far away (mapwalk / ranged combat)
			if (lastTouchPosition_dx == 0 && lastTouchPosition_dy == 0) return false;
			if (Math.abs(lastTouchPosition_dx) > 1) return false;
			if (Math.abs(lastTouchPosition_dy) > 1) return false;

			controllers.combatController.setCombatSelection(lastTouchPosition_tileCoords);
			return true;
		}
		return false;
	}

	private boolean allowInputInterval() {
		final long now = System.currentTimeMillis();
		if ((now - lastTouchEventTime) < Constants.MINIMUM_INPUT_INTERVAL) return false;
		lastTouchEventTime = now;
		return true;
	}

	public void setDpadActive(boolean isDpadActive) {
		this.isDpadActive = isDpadActive;
	}

	public void onTouchCancel() {
		controllers.movementController.stopMovement();
	}

	public boolean onTouchedTile(int tile_x, int tile_y) {
		lastTouchPosition_tileCoords.set(tile_x, tile_y);
		lastTouchPosition_dx = tile_x - world.model.player.position.x;
		lastTouchPosition_dy = tile_y - world.model.player.position.y;

		if (world.model.uiSelections.isInCombat || isDpadActive) return false;

		controllers.movementController.startMovement(lastTouchPosition_dx, lastTouchPosition_dy, lastTouchPosition_tileCoords);
		return true;
	}
}
