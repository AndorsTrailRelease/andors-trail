package com.gpl.rpg.AndorsTrail.controller;

import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnLongClickListener;

import com.gpl.rpg.AndorsTrail.context.ControllerContext;
import com.gpl.rpg.AndorsTrail.context.WorldContext;
import com.gpl.rpg.AndorsTrail.util.Coord;
import com.gpl.rpg.AndorsTrail.util.L;

public final class InputController implements OnClickListener, OnLongClickListener{
	private final ControllerContext controllers;
	private final WorldContext world;

	private final Coord lastTouchPosition_tileCoords = new Coord();
	private int lastTouchPosition_dx = 0;
	private int lastTouchPosition_dy = 0;
	private long lastTouchEventTime = 0;
	private boolean isDpadActive = false;

	private int keyState_dx = 0;
	private int keyState_dy = 0;
	private boolean keyState_attack = false;
	private boolean keyState_flee = false;
	private boolean keyState_endturn = false;

	public InputController(ControllerContext controllers, WorldContext world) {
		this.controllers = controllers;
		this.world = world;
	}

/*	New keyboard handler.  Both Key Down and Key Up events handled to allow conditional behaviours.
	On 4-way dpad controllers, cursor keys, and WASD, diagonals are generated by chording two keys.
	Single-key diagonals are supported on numeric keypad and 8-way dpads (not seen/tested in the wild).

    Because two-key combos initially generate a ordinal movement (one key comes in first), which can
    be dangerous in tight spaces, modifiers are provided to "lock" the input until both keys are down.
    TODO: Use delay timer to enable chorded diagonals on first move?
 */
	public boolean onKeyboardAction(KeyEvent event, boolean canAcceptInput) {
//		L.log("onKeyboardAction(): Processing action " + event.getAction() + " for keyCode " + event.getKeyCode());

		if (event.getAction() != KeyEvent.ACTION_DOWN && event.getAction() != KeyEvent.ACTION_UP) return false; // don't handle other actions

		// Android provides artificial ACTION_UP events when focus changes; we need them to prevent "stuck key" effect after dialogs close
		if (!canAcceptInput && event.getAction() == KeyEvent.ACTION_DOWN) return false;

		boolean keydown = (event.getAction() == KeyEvent.ACTION_DOWN);
		boolean cancel = false; // used cancel final direction handling if already handled in switch()

		switch (event.getKeyCode()) {
			// Ordinal directional keys - only modify one direction register, can be combined when
			// used simultaneously to create synthetic diagonals
			case KeyEvent.KEYCODE_DPAD_UP:
			case KeyEvent.KEYCODE_NUMPAD_8:
			case KeyEvent.KEYCODE_8:
			case KeyEvent.KEYCODE_W:
				keyState_dy = keydown ? -1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_DOWN:
			case KeyEvent.KEYCODE_NUMPAD_2:
			case KeyEvent.KEYCODE_2:
			case KeyEvent.KEYCODE_S:
				keyState_dy = keydown ? 1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_LEFT:
			case KeyEvent.KEYCODE_NUMPAD_4:
			case KeyEvent.KEYCODE_4:
			case KeyEvent.KEYCODE_A:
				keyState_dx = keydown ? -1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_RIGHT:
			case KeyEvent.KEYCODE_NUMPAD_6:
			case KeyEvent.KEYCODE_6:
			case KeyEvent.KEYCODE_D:
				keyState_dx = keydown ? 1 : 0;
				break;

			// Diagonal directional keys.  Modify both direction registers, can't be combined
			// TODO: store individual key position to allow combinations.  May not be worth the trouble.
			case KeyEvent.KEYCODE_DPAD_UP_LEFT:
			case KeyEvent.KEYCODE_NUMPAD_7:
			case KeyEvent.KEYCODE_7:
			case KeyEvent.KEYCODE_MOVE_HOME:
				keyState_dx = keydown ? -1 : 0;
				keyState_dy = keydown ? -1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_UP_RIGHT:
			case KeyEvent.KEYCODE_NUMPAD_9:
			case KeyEvent.KEYCODE_9:
			case KeyEvent.KEYCODE_PAGE_UP:
				keyState_dx = keydown ? 1 : 0;
				keyState_dy = keydown ? -1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_DOWN_LEFT:
			case KeyEvent.KEYCODE_NUMPAD_1:
			case KeyEvent.KEYCODE_1:
			case KeyEvent.KEYCODE_MOVE_END:
				keyState_dx = keydown ? -1 : 0;
				keyState_dy = keydown ? 1 : 0;
				break;
			case KeyEvent.KEYCODE_DPAD_DOWN_RIGHT:
			case KeyEvent.KEYCODE_NUMPAD_3:
			case KeyEvent.KEYCODE_3:
			case KeyEvent.KEYCODE_PAGE_DOWN:
				keyState_dx = keydown ? 1 : 0;
				keyState_dy = keydown ? 1 : 0;
				break;

			// "Attack" shortcut - freeze movement to allow chorded direction when key is released.
			// if in combat, executes an attack on key release
			case KeyEvent.KEYCODE_DPAD_CENTER: // Not sure if this is needed
			case KeyEvent.KEYCODE_BUTTON_A: // lock movement until released for precise directional move/attack
			case KeyEvent.KEYCODE_SPACE:
			case KeyEvent.KEYCODE_NUMPAD_5:
				if (!keydown && keyState_attack) { // key released - execute attack
					if(!world.model.uiSelections.isInCombat) {
						controllers.movementController.stopMovement();
					} else if (allowInputInterval()) {
						controllers.combatController.executeMoveAttack(keyState_dx, keyState_dy);
					}
				}
				keyState_attack = keydown; // prevents movement event below if pressed
				cancel = false; //don't cancel, allow pending movement immediately on release via code below
				break;

			// "Flee" shortcut.  Intitiates flee when pressed.  If a direction is held, moves in chosen direction when released
			case KeyEvent.KEYCODE_BUTTON_X:
			case KeyEvent.KEYCODE_F:
			case KeyEvent.KEYCODE_NUMPAD_ENTER:
			case KeyEvent.KEYCODE_ENTER:
				if (world.model.uiSelections.isInCombat) {
					if (keydown && !keyState_flee) { // button pressed
						controllers.combatController.startFlee();
					} else if (!keydown && keyState_flee) { // button released - move flee direction, if chosen
						// if no movement, executeMoveAttack() will just attack again, so we have to check and do it here
						if ((keyState_dx != 0 || keyState_dy != 0) && allowInputInterval()) {
							controllers.combatController.executeMoveAttack(keyState_dx, keyState_dy);
						}
						cancel = true;
					}
				}
				keyState_flee = keydown;
				break;

			// "End Turn" shortcut.  Prevents repeated end turn if key is held down.
			case KeyEvent.KEYCODE_BUTTON_Y:
			case KeyEvent.KEYCODE_E:
			case KeyEvent.KEYCODE_FORWARD_DEL:
			case KeyEvent.KEYCODE_NUMPAD_DOT:
				if (keydown && !keyState_endturn) {
					if (world.model.uiSelections.isInCombat) controllers.combatController.endPlayerTurn();
				}
				keyState_endturn = keydown;
				cancel = true;
				break;
			default: // unhandled key
				return false;
		}

		/* process movement if not already handled above and action modifier button is not down.
		   Modifiers allow input from 4-way controller or keyboard to settle (e.g., combined keys
		   for diagonals) before action is taken.
		 */
		if (!cancel && !keyState_attack && !keyState_endturn && !keyState_flee) {
			if (world.model.uiSelections.isInCombat) {
				if (keydown && allowInputInterval()) controllers.combatController.executeMoveAttack(keyState_dx, keyState_dy);
			} else if (keyState_dx == 0 && keyState_dy == 0) {
				controllers.movementController.stopMovement();
			} else {
				controllers.movementController.startMovement(keyState_dx, keyState_dy, null);
			}
		}
		return true;
	}

	public void onRelativeMovement(int dx, int dy) {
		if (world.model.uiSelections.isInCombat) {
			if (!allowInputInterval()) return;
			controllers.combatController.executeMoveAttack(dx, dy);
		} else {
			controllers.movementController.startMovement(dx, dy, null);
		}
	}

	public void onKeyboardCancel() {
		controllers.movementController.stopMovement();
	}

	@Override
	public void onClick(View arg0) {
		if (!world.model.uiSelections.isInCombat) return;
		onRelativeMovement(lastTouchPosition_dx, lastTouchPosition_dy);
	}

	@Override
	public boolean onLongClick(View arg0) {
		if (world.model.uiSelections.isInCombat) {
			//TODO: Should be able to mark positions far away (mapwalk / ranged combat)
			if (lastTouchPosition_dx == 0 && lastTouchPosition_dy == 0) return false;
			if (Math.abs(lastTouchPosition_dx) > 1) return false;
			if (Math.abs(lastTouchPosition_dy) > 1) return false;

			controllers.combatController.setCombatSelection(lastTouchPosition_tileCoords);
			return true;
		}
		return false;
	}

	private boolean allowInputInterval() {
		final long now = System.currentTimeMillis();
		if ((now - lastTouchEventTime) < Constants.MINIMUM_INPUT_INTERVAL) return false;
		lastTouchEventTime = now;
		return true;
	}

	public void setDpadActive(boolean isDpadActive) {
		this.isDpadActive = isDpadActive;
	}

	public void onTouchCancel() {
		controllers.movementController.stopMovement();
	}

	public boolean onTouchedTile(int tile_x, int tile_y) {
		lastTouchPosition_tileCoords.set(tile_x, tile_y);
		lastTouchPosition_dx = tile_x - world.model.player.position.x;
		lastTouchPosition_dy = tile_y - world.model.player.position.y;

		if (world.model.uiSelections.isInCombat || isDpadActive) return false;

		controllers.movementController.startMovement(lastTouchPosition_dx, lastTouchPosition_dy, lastTouchPosition_tileCoords);
		return true;
	}
}
